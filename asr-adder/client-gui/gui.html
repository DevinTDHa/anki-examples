<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ASR Adder</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    .container {
      margin-top: 20px;
    }

    table {
      margin-top: 20px;
    }

    .table-wrapper {
      max-height: 300px;
      overflow-y: auto;
    }

    .recording {
      background-color: red;
      color: white;
    }

    .spinner-border {
      width: 1rem;
      height: 1rem;
    }

    #recordBtn {
      width: 150px;
    }
  </style>
</head>

<body>
  <div class="container" style="max-width: 800px;">
    <h3>ASR Adder</h3>
    <p>This app will record audio when you press the button and send it to the cloze-wikt server to transcribe and
      extract wiktionary entries. The results can then be saved to a csv for further processing.</p>

    <!-- URL input -->
    <div class="input-group mb-3">
      <span class="input-group-text">URL</span>
      <input type="text" id="url" class="form-control" placeholder="http://localhost:5000/process_audio"
        onclick="autofillPlaceholder(this)">
      <button class="btn btn-primary" id="testBtn">Test</button>
      <!-- TODO: Maybe switch for max n-grams int?  -->
    </div>

    <!-- Record button and output text in same row -->
    <div class="row mb-3">
      <div class="col-auto d-flex flex-column">
        <button class="btn btn-primary mb-2" id="recordBtn">Record</button>
        <button class="btn btn-success" id="playBackBtn" disabled>Play Back</button>
      </div>
      <div class="col">
        <input type="text" id="outputText" class="form-control" placeholder="Transcribed text" disabled>
      </div>
    </div>

    <!-- Results Table wrapped in a proper row div -->
    <div class="row">
      <div class="col-12">
        <div class="table-wrapper" , style="max-width: 700; max-height: none;">
          <table class="table table-striped">
            <thead>
              <tr>
                <th class="col-3">Word</th>
                <th class="col-8">Definition</th>
                <th class="col-1"></th>
              </tr>
            </thead>
            <tbody id="resultsTable">
              <!-- Rows will be inserted here by JavaScript -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Clear and Save As Buttons -->
    <div class="row m-3">
      <div class="col-md-6">
        <div class="input-group">
          <button class="btn btn-primary" id="saveBtn">Save as</button>
          <input type="text" id="saveFileName" class="form-control" placeholder="results.txt"
            onclick="autofillPlaceholder(this)">
          <small class="form-text text-muted">Only the word itself is saved. Use the other scripts to fill the
            rest.</small>
        </div>
      </div>
      <div class="col-md-3 text-end">
        <button class="btn btn-primary" id="clearDuplicates" onmouseover="this.style.backgroundColor='red'"
          onmouseout="this.style.backgroundColor=''">Clear ✅</button>
      </div>
      <div class="col-md-3 text-end">
        <button class="btn btn-primary" id="clearBtn" onmouseover="this.style.backgroundColor='red'"
          onmouseout="this.style.backgroundColor=''">Clear Entries</button>
      </div>
    </div>
  </div>

  <script>
    // State
    let chunks = [];
    let mediaRecorder;
    let recordingInterval;
    let recordingTime = 0;
    let audioURL;  // Store the audio URL here
    let playbackAudio;

    function autofillPlaceholder(element) {
      if (!element.value) {
        element.value = element.placeholder;
      }
    }

    // Format time in MM:SS
    function formatTime(seconds) {
      const minutes = Math.floor(seconds / 60).toString().padStart(2, '0');
      const secs = (seconds % 60).toString().padStart(2, '0');
      return `${minutes}:${secs}`;
    }

    // Start recording
    document.getElementById('recordBtn').addEventListener('click', function () {
      // Disable the Play Back button, new recording
      const playBackBtn = document.getElementById('playBackBtn');
      playBackBtn.disabled = true;

      // Record Button logic
      const recordBtn = document.getElementById('recordBtn');

      // If it's in recording state, stop recording
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        clearInterval(recordingInterval);
        recordBtn.disabled = true;
        recordBtn.innerHTML = '<div class="spinner-border" role="status"></div>'; // Show spinner
        return;
      }

      // Start recording
      navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.start();
        recordingTime = 0;
        recordBtn.classList.add('recording');
        recordBtn.textContent = `Stop 00:00`;

        // Update the recording time every second
        recordingInterval = setInterval(() => {
          recordingTime++;
          recordBtn.textContent = `Stop ${formatTime(recordingTime)}`;
        }, 1000);

        mediaRecorder.ondataavailable = function (e) {
          chunks.push(e.data);
        };

        mediaRecorder.onstop = function () {
          const blob = new Blob(chunks, { type: 'audio/wav' });
          chunks = [];
          sendAudio(blob);

          // Enable the Play Back button
          const playBackBtn = document.getElementById('playBackBtn');
          playBackBtn.disabled = false;

          // Create an audio element for playback
          audioURL = URL.createObjectURL(blob);
          playbackAudio = new Audio(audioURL);
        };


        // Play the recorded audio on click
        document.getElementById('playBackBtn').addEventListener('click', function () {
          if (playbackAudio) {
            playbackAudio.play();
          }
        });

      });
    });

    // Send recorded audio to the server
    function sendAudio(audioBlob) {
      const url = document.getElementById('url').value || document.getElementById('url').placeholder;
      const formData = new FormData();
      formData.append('audio', audioBlob, 'audio.wav');

      fetch(url, {
        method: 'POST',
        body: formData
      })
        .then(response => response.json())
        .then(data => {
          // Handle server response
          console.log('Success:', data);
          const outputText = data.transcription;
          document.getElementById('outputText').value = outputText;

          const resultsTable = document.getElementById('resultsTable');
          const existsInDeck = data.existing_words;

          Object.entries(data.result).forEach(([word, definition]) => {
            const existingWords = Array.from(document.querySelectorAll('#resultsTable td:first-child')).map(td => td.textContent);
            if (!existingWords.includes(word)) {
              let row = document.createElement('tr');

              const wordCell = document.createElement('td');
              wordCell.textContent = word;

              // Highlight duplicates
              if (existsInDeck.includes(word)) {
                row.classList.add('duplicateEntry');
                wordCell.textContent = word + ' ✅';
              }

              row.appendChild(wordCell);

              const definitionCell = document.createElement('td');
              if (definition.short.length > 300) {
                definitionCell.textContent = definition.short.substring(0, 300) + '...';
              } else {
                definitionCell.textContent = definition.short;
              }
              row.appendChild(definitionCell);

              const actionCell = document.createElement('td');
              const deleteBtn = document.createElement('button');
              deleteBtn.classList.add('btn', 'btn-danger', 'btn-sm');
              deleteBtn.innerHTML = '⌫';
              deleteBtn.addEventListener('click', () => row.remove());
              actionCell.appendChild(deleteBtn);
              row.appendChild(actionCell);

              resultsTable.appendChild(row);
            }
          });

          // Reset button after response
          const recordBtn = document.getElementById('recordBtn');
          recordBtn.disabled = false;
          recordBtn.classList.remove('recording');
          recordBtn.textContent = 'Record';
        })
        .catch(error => {
          console.error('Error:', error);
          // Reset button even if there's an error
          const recordBtn = document.getElementById('recordBtn');
          recordBtn.disabled = false;
          recordBtn.classList.remove('recording');
          recordBtn.textContent = 'Record';
        });
    }

    // Clear the duplicates, tr that has the class duplicateEntry
    document.getElementById('clearDuplicates').addEventListener('click', function () {
      const duplicateEntries = document.querySelectorAll('.duplicateEntry');
      duplicateEntries.forEach(entry => entry.remove());
    });

    // Clear the results table
    document.getElementById('clearBtn').addEventListener('click', function () {
      document.getElementById('resultsTable').innerHTML = '';
      document.getElementById('outputText').value = '';
    });

    // Save results to a file
    document.getElementById('saveBtn').addEventListener('click', function () {
      const resultsTable = document.getElementById('resultsTable');
      const fileName = document.getElementById('saveFileName').value || document.getElementById('saveFileName').placeholder;

      let fileContent = '';

      // TODO: Proper formatting of output here
      for (const row of resultsTable.rows) {
        if (row.classList.contains('duplicateEntry')) {
          continue;
        }
        const word = row.cells[0].textContent;
        // const definition = row.cells[1].textContent;
        fileContent += `${word}\n`;
      }

      const blob = new Blob([fileContent], { type: 'text/plain' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = fileName;
      link.click();
    });

    // Test button placeholder
    document.getElementById('testBtn').addEventListener('click', function () {
      let url = document.getElementById('url').value || document.getElementById('url').placeholder;
      const baseUrl = new URL(url).origin + "/deck"; // Get deck URL

      fetch(baseUrl)
        .then(response => {
          if (response.status === 200) {
            this.disabled = true;
            this.style.backgroundColor = 'green';
            response.json().then(data => {
              if (data.deck > 0) {
                this.innerHTML = `✅ Deck Size: ${data.deck}`;
              }
            });

          } else {
            this.style.backgroundColor = 'red';
          }
        })
        .catch(error => {
          console.error('Error:', error);
          this.style.backgroundColor = 'red';
        });
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>